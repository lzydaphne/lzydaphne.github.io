

<!DOCTYPE html>
<html lang="zh-TW" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/run.png">
  <link rel="icon" href="/assets/run.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#494e6b">
  <meta name="author" content="lzydaphne">
  <meta name="keywords" content="">
  
    <meta name="description" content="Ch1 GPU 硬體基礎硬體方面的研究通常是不同設計間的 trade-off本書主要是在提出這些已經被研究過的設計考量，並提高在非圖形計算類的應用程式的 performance 和 energy efficiency 本書內文是作者根據各種不同文獻、專利來敘述，有些細節可能跟實際產品的架構不同，不能盡信 1-1 歷史背景幾十年來，連續幾代計算系統的每美元效能呈指數級增長。根本原因是電晶體尺寸的減少">
<meta property="og:type" content="article">
<meta property="og:title" content="GPGPU-CH1">
<meta property="og:url" content="https://lzydaphne.github.io/2024/01/20/GPGPU-CH1/index.html">
<meta property="og:site_name" content="On the Road">
<meta property="og:description" content="Ch1 GPU 硬體基礎硬體方面的研究通常是不同設計間的 trade-off本書主要是在提出這些已經被研究過的設計考量，並提高在非圖形計算類的應用程式的 performance 和 energy efficiency 本書內文是作者根據各種不同文獻、專利來敘述，有些細節可能跟實際產品的架構不同，不能盡信 1-1 歷史背景幾十年來，連續幾代計算系統的每美元效能呈指數級增長。根本原因是電晶體尺寸的減少">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://lzydaphne.github.io/assets/240120.png">
<meta property="article:published_time" content="2024-01-20T01:06:13.000Z">
<meta property="article:modified_time" content="2024-01-20T01:19:07.676Z">
<meta property="article:author" content="lzydaphne">
<meta property="article:tag" content="GPU">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lzydaphne.github.io/assets/240120.png">
  
  
  
  <title>GPGPU-CH1 | On the Road</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lzydaphne.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":75,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="On the Road" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>On the Road</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Articles</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/assets/page.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="GPGPU-CH1"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-20 09:06" pubdate>
          2024年1月20日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          7.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          65 分鐘
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">GPGPU-CH1</h1>
            
              <p class="note note-info">
                
                  
                    <!-- compatible with older versions-->
                    本文最後更新於：2024年1月20日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="Ch1-GPU-硬體基礎"><a href="#Ch1-GPU-硬體基礎" class="headerlink" title="Ch1 GPU 硬體基礎"></a>Ch1 GPU 硬體基礎</h1><p>硬體方面的研究通常是不同設計間的 trade-off<br>本書主要是在提出這些已經被研究過的設計考量，並提高在非圖形計算類的應用程式的 performance 和 energy efficiency</p>
<p>本書內文是作者根據各種不同文獻、專利來敘述，有些細節可能跟實際產品的架構不同，不能盡信</p>
<h2 id="1-1-歷史背景"><a href="#1-1-歷史背景" class="headerlink" title="1-1 歷史背景"></a>1-1 歷史背景</h2><p>幾十年來，連續幾代計算系統的每美元效能呈指數級增長。根本原因是電晶體尺寸的減少、硬體架構的改進、編譯器技術和演算法的改進</p>
<p>然而，大約自 2005 年以來，電晶體的縮放比例未能遵循 <strong>Dennard Scaling</strong> [Dennard et al., 1974] 規則。所以目前，clock rate 增長的速度緩於裝置變小的速度。</p>
<ul>
<li>Dennard scaling：隨著電晶體變得越來越小，它們的功率密度保持不變，所以電晶體尺寸越小，能耗就會成比例的減少，在同個晶片上可以容納更多電晶體，使得裝置可以在不會過熱的情況下執行得更快(clock rate 更高)。</li>
</ul>
<p>隨著登納德縮放比例定律（Dennard Scaling）的失效，增加能源效率（energy efficiency）是目前計算機架構研究中主要的動力<br>一個重要的觀察結果就是：”存取” 大型儲存結構所消耗的能量，實際上與 “計算” 消耗的能量一樣多，甚至更多。表 1.1 所提供的 45nm 製程中各操作的能量數據 [Han et al., 2016] 就是一個例子。<br><img src="https://s2.loli.net/2024/01/10/b9FdwM8fxqXNgih.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>為了提高性能，需要找到更有效率的硬體架構，下列是一些能夠改善 energy efficiency 的方式：</p>
<ul>
<li>hardware specialization<ul>
<li>使用類似 GPU 的 vector HW，可以減少指令處理的成本</li>
</ul>
</li>
<li>minimize data movement<ul>
<li>how? 執行複合操作的指令(在避免大型記憶體存取的前提下，可以一次執行多個算術操作)</li>
</ul>
</li>
</ul>
<p>當前架構面臨的挑戰：效率 vs 彈性：</p>
<ul>
<li>專用硬體通常更有效率，但彈性較差</li>
<li>通用型的可以支援更多 program</li>
</ul>
<p>如果沒有靈活的架構，只有那些能在現有專用硬體上有效執行的演算法才能獲得性能提升，高效運算的範圍被限制在某些特定任務。<br>雖然有一個趨勢朝向更專用的硬體(機器學習)，但總會有對通用計算的需求。</p>
<h2 id="1-2-GPU-硬體架構"><a href="#1-2-GPU-硬體架構" class="headerlink" title="1-2 GPU 硬體架構"></a>1-2 GPU 硬體架構</h2><h3 id="GPU-和-CPU-架構的差異"><a href="#GPU-和-CPU-架構的差異" class="headerlink" title="GPU 和 CPU 架構的差異"></a>GPU 和 CPU 架構的差異</h3><p><img src="https://s2.loli.net/2024/01/12/Gh2E9Tn7AHi8QLV.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>CPU (中央處理單元)</th>
<th>GPU (圖形處理單元)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>設計焦點</strong></td>
<td>針對 sequential code 優化</td>
<td>針對浮點計算和 memory bandwidth 優化</td>
</tr>
<tr>
<td><strong>主要任務</strong></td>
<td>通用計算任務，包括複雜的邏輯和分支決策</td>
<td>圖形處理和高度平行化的計算任務</td>
</tr>
<tr>
<td><strong>硬體架構</strong></td>
<td>較少的核心，但每個核心擁有高度優化的性能</td>
<td>大量核心，專注於平行處理</td>
</tr>
<tr>
<td><strong>算術單元</strong></td>
<td>適合複雜運算，如分支和控制邏輯</td>
<td>maximize 浮點計算能力</td>
</tr>
<tr>
<td><strong>記憶體</strong></td>
<td>大型的 cache 和 memory</td>
<td>簡化的記憶體系統，通常擁有和需要更高的 memory bandwidth</td>
</tr>
<tr>
<td><strong>適用場景</strong></td>
<td>適用於高性能單執行緒和快速分支預測的任務</td>
<td>適用於需要大規模數據處理和高度平行化的任務</td>
</tr>
<tr>
<td><strong>記憶體頻寬</strong></td>
<td>相對較低的 memory bandwidth</td>
<td>高達 10 倍於 CPU 的 memory bandwidth</td>
</tr>
<tr>
<td><strong>設計理念</strong></td>
<td>latency-oriented，minimize 算術操作的 latency</td>
<td>throughput-oriented，提高整體處理能力</td>
</tr>
</tbody></table>
<h3 id="GPU-和-CPU-的溝通"><a href="#GPU-和-CPU-的溝通" class="headerlink" title="GPU 和 CPU 的溝通"></a>GPU 和 CPU 的溝通</h3><p>目前 GPU 並不是可以 stand-alone computing 的設備，所以考慮的形式是 GPU 和 CPU 進行溝通</p>
<ul>
<li>GPU 和 CPU 的通訊<ul>
<li>目前的 GPU 可能和 CPU 整合在一個晶片上，</li>
<li>或是 GPU 插在主機板上透過 PCIE 和 CPU 進行通訊，CPU 用於初始化計算，並且將資料透過 PCIE 匯流排傳入到 GPU 中<ul>
<li>PCIE 通訊速率也是 GPU 的瓶頸之一，因為 PCIE 傳輸對於 GPU 來說太慢了</li>
</ul>
</li>
</ul>
</li>
<li>GPU 和 CPU 的 I/O<ul>
<li>目前為止 CPU 中有北橋可以存取 main memory，有中斷器可以對應 input 設備，CPU 還提供了一套 API 去存取 IO，</li>
<li>但是 GPU 雖然說做到這些不難， 但是還沒有廠商實現。</li>
<li>操作系統也是一個問題，GPU 一般平行處理數據，但是操作系統要求平行處理資料的場景比較少</li>
</ul>
</li>
</ul>
<p>下面是 CPU 和 GPU 的兩種架構，<br><img src="https://s2.loli.net/2024/01/08/5HfOxeLQP13q8Ak.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<table>
<thead>
<tr>
<th>Device</th>
<th>Memory</th>
<th>DRAM Technology</th>
<th>Optimization</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>系統記憶體（system memory）</td>
<td>DDR</td>
<td>Lower latency</td>
</tr>
<tr>
<td>GPU</td>
<td>裝置記憶體（device memory）</td>
<td>GDDR</td>
<td>Higher throughput</td>
</tr>
</tbody></table>
<ul>
<li><p>左邊是 GPU 直接插入 PCIE 插槽</p>
<ul>
<li>CPU 和 GPU 帶有獨立的 DRAM menory space 和 不同的 DRAM 技術<ul>
<li>CPU 的記憶體通常被稱為系統記憶體（system memory），GPU 的則通常被稱為裝置記憶體（device memory）</li>
<li>不同的 DRAM 技術：system memory 使用 DDR ，device memory 使用 GDDR</li>
<li>CPU 的 DRAM 通常會優先優化 access latency，而 GPU 的 RAM 則優先優化 throughput</li>
</ul>
</li>
</ul>
</li>
<li><p>右邊是 GPU 和 CPU 整合成一個晶片(AMD 的 APU)，只擁有單一的 DRAM 記憶體空間，因此必須使用相同的記憶體技術。</p>
<ul>
<li>由於整合 CPU 和 GPU 的晶片經常出現在低功耗的行動裝置上，因此這種共享的 DRAM 記憶體往往會針對功耗進行最佳化（如 LPDDR）。</li>
</ul>
</li>
</ul>
<h3 id="近代不同的架構設計"><a href="#近代不同的架構設計" class="headerlink" title="近代不同的架構設計"></a>近代不同的架構設計</h3><ul>
<li><p>在 NVIDIA 和 AMD 較舊的獨立 GPU 上，CPU 通常會在 CPU 和 GPU 的 memory space 中，為資料結構分配空間。</p>
<ul>
<li>對於這些 GPU，CPU 執行部分必須協調將 data 從 CPU 記憶體移至 GPU 記憶體。</li>
</ul>
</li>
<li><p>最近的獨立 GPU（如 NVIDIA 的 Pascal 架構），則可透過相關的軟硬體支持，自動地將資料從 CPU 記憶體轉移到 GPU 記憶體中。</p>
<ul>
<li>How?<ul>
<li>這可透過利用 CPU 和 GPU 對虛擬記憶體的支援來實現 [Gelado et al., 2010]。</li>
<li>NVIDIA 將此稱為「統一記憶體（unified memory）」。</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU 和 GPU 被整合在同一晶片，並共享相同記憶體的系統</p>
<ul>
<li>不需要由人來將 GPU 記憶體複製到 GPU 記憶體。然而，由於 CPU 和 GPU 都是用了 cache，並且其中一些 cache 是 private 的，因此這裡可能會出現緩存一致性（cache coherence）的問題，這點需要由硬體開發商來解決 [Power et al., 2013b]。</li>
</ul>
</li>
</ul>
<p>::: success<br>怎麼從 CPU 開始呼叫 GPU 進行運算?<br>:::</p>
<h3 id="GPU-啟動運算的程序"><a href="#GPU-啟動運算的程序" class="headerlink" title="GPU 啟動運算的程序"></a>GPU 啟動運算的程序</h3><ol>
<li>在 GPU 上啟動運算前，在 CPU 上的 GPU 計算程式，要 <strong>指定哪些程式碼應該在 GPU 上運作</strong>。<ol>
<li>這些程式碼通常被稱作 <code>kernel</code>，是使用 GPU 程式語言（如 CUDA 或 OpenCL）編寫的函數，專門在 GPU 的平行架構上運行。</li>
</ol>
</li>
<li>同時，在 CPU 上的 GPU 計算程式也 <strong>指定了要執行執行緒的數量</strong>，以及 <strong>這些執行緒應該從哪裡取得輸入資料</strong>。</li>
<li>要運行的 kernel、執行緒的數量和資料的位置是由 CPU 上執行的驅動程式(driver)傳遞給 GPU 硬體的。</li>
<li>驅動程式作為中介，將這些資訊轉換為 GPU 可以理解的指令，並將它們放置在 GPU 可存取的記憶體中。</li>
<li>隨後，驅動程式向 GPU 發送訊號，告訴 GPU 要進行新的運算。</li>
</ol>
<p>::: success<br>開始運算後，現代 GPU 常用 SIMT 架構來執行平行化的計算<br>:::</p>
<h3 id="SIMT-Single-Instruction-Multiple-Threads"><a href="#SIMT-Single-Instruction-Multiple-Threads" class="headerlink" title="SIMT (Single-Instruction, Multiple Threads)"></a>SIMT (Single-Instruction, Multiple Threads)</h3><p>what: 是一種現代 GPU 常用架構</p>
<ul>
<li>使 GPU 能夠平行執行許多 thread，使其在可以分解為許多同時進行的小操作</li>
<li>NVIDIA 將這些 core 稱為串流多處理器（SM, streaming multiprocessor），AMD 則將它們稱為運算單元（compute unit）</li>
</ul>
<p><img src="https://s2.loli.net/2024/01/08/wKIgUNpaB14x3AL.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><strong>SIMT Core Cluster</strong></p>
<ul>
<li>What?<ul>
<li>這是多個 SIMT core 的分組。</li>
<li>可以同時使用相同指令但不同資料，來執行多個 Threads。</li>
</ul>
</li>
<li>Why?<ul>
<li>這在圖形處理中特別有用，因為同一操作通常應用於許多像素或頂點。</li>
</ul>
</li>
</ul>
<p><strong>SIMT core</strong></p>
<ul>
<li>What?<ul>
<li>每個 SIMT core 能夠同時執行多個(數千個)執行緒，為高度平行的設計，這對於通常由 GPU 處理的大規模平行工作負載來說是理想的。</li>
</ul>
</li>
</ul>
<p><strong>Memory Partition(記憶體分區):</strong></p>
<ul>
<li>What?<ul>
<li>GPU 中的記憶體被分成多個分割區(Partition)，允許多個 SIMT core 同時存取。</li>
</ul>
</li>
<li>Why?<ul>
<li>這種分割對於保持高吞吐量至關重要，因為它最小化了記憶體存取瓶頸</li>
<li>如果所有 core 都存取單一記憶體池，將會發生記憶體存取瓶頸。</li>
</ul>
</li>
</ul>
<p><strong>Interconnection Network:</strong></p>
<ul>
<li>What?<ul>
<li>這是連接 SIMT Core Cluster 與 Memory Partition 的 data pathway。它被設計成能夠處理高 bandwidth ，以實現快速數據交換</li>
</ul>
</li>
<li>Why?<ul>
<li>這對於維持 core 性能和記憶體訪問效率至關重要。</li>
</ul>
</li>
</ul>
<p>::: success<br>從更上層的視角來看整個 GPU 的內部架構:<br>:::</p>
<h3 id="GPU-內部架構"><a href="#GPU-內部架構" class="headerlink" title="GPU 內部架構:"></a>GPU 內部架構:</h3><p>Why? 在 thread 之間以不高的成本快速切換(context switch)，是 GPU 維持高使用率和效率的關鍵</p>
<ul>
<li>GPU 計算非常快，速度慢的瓶頸是 memory access，所以會不斷 context switch，達到 <strong>隱藏延遲</strong> 的效果（hide memory access latency）<ul>
<li>一個 core 中可以讓很多 threads 共用，其中一個 thread 如果要進行 memory access，就可以觸發 context switch，讓另一個 thread 來使用，以達到 hide (memory access) latency 的功能</li>
<li>CUDA 中，每個 thread 都有自己的 <strong>register set</strong>，所以 context switch 時基本上不用動到 register 裡面的值</li>
</ul>
</li>
</ul>
<p>How? 這些 GPU cores 將負責執行在 GPU 上啟動的 kernel 程序，以單指令多執行緒（SIMT）的方式執行，所以 GPU 上的每個 core 通常可以運行上千個 threads。</p>
<ul>
<li>同處在單一 core 上執行的 threads<ul>
<li>可透過草稿記憶體（scratchpad memory, shared, fast-access memory area）來溝通</li>
<li>可以透過一些高速屏障操作（barrier operations）進行同步。</li>
<li>每個 core 內部通常也會包含 L1 instruction cache 和 L1 data cache，可充當 bandwidth filter 以減少到較低階記憶體系統的通訊量。</li>
</ul>
</li>
<li>高水準的計算吞吐量（ high computational throughput ），有必要和 high memory bandwidth 間進行平衡。high memory bandwidth 很重要，因為它能夠讓 GPU 快速 load 和 store 計算所需的大量資料。</li>
</ul>
<p>為了達到這種平衡，我們在記憶體系統加入平行性（parallelism），通過以下架構特點實現：</p>
<p><strong>Multiple Memory Channels</strong>:</p>
<ul>
<li>主記憶體會被切成多個記憶體分區（memory partisions），每個 Partision 會連結到一個記憶體通道（memory channel）</li>
<li>在 GPU 中，這種平行性是由 GPU 所包含的多個 memory channel 提供的</li>
<li>每個 channel 都是一個獨立的路徑，用於 data 在 memory 和 GPU core 之間的流動。</li>
<li>所以通過擁有多個 channel，GPU 可以同時處理更多的 data，從而增加了可供 GPU core 使用的總體 memory bandwidth</li>
</ul>
<p><strong>Last-Level Cache Association</strong>:</p>
<blockquote>
<p>Last level cache (LLC) refers to <strong>the highest-numbered cache that is accessed by the cores prior to fetching from memory</strong>. Usually, LLC is shared by all the cores. In Skylake and Cascade Lake, the LLC is the shared L3 cache.</p>
</blockquote>
<ul>
<li>每個 memory channels 都會和一部分的 LLC 連結</li>
</ul>
<p><strong>On-Chip Interconnection Network</strong>:<br>GPU core 透過 on-chip network，如 crossbar，來與 memory partisions 連接。</p>
<ul>
<li>其它架構也是可能的，例如在超算市場上與 GPU 直接競爭的 Intel 的 Xeon Phi，就將 LLC 分配給了各個 core</li>
</ul>
<p>::: success<br>重點關注 core 和 thread 之間的關係<br>:::</p>
<h3 id="架構分析-core-thread"><a href="#架構分析-core-thread" class="headerlink" title="架構分析(core, thread)"></a>架構分析(core, thread)</h3><p>與 CPU 相比，GPU 可將其晶片面積中的更大部分用於 ALU（arithmetic logic units），並減少用於控制邏輯的面積，從而獲得更好的單位面積性能（performance per unit area）。<br><img src="https://s2.loli.net/2024/01/10/mYhlV7anq4j2gAF.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>圖 1.3，對多核心（MC）CPU 架構和多執行緒（MT）架構（如 GPU）間的效能權衡的模型分析表明，如果執行緒數量不足以覆蓋 off-chip memory 的 memory access latency，就會出現「效能谷（ performance valley）」（基於 Guz et al.[2009] 的 Figure 1）</p>
</blockquote>
<p>為幫助對 CPU 和 GPU 架構間的權衡有一個直觀的認識，Guz 等人（Guz et al. [2009]）開發了一個分析模型，以顯示性能是如何隨 thread 數量的變化而變化的。</p>
<p>模型前提:</p>
<ul>
<li>thread 不會共享資料，</li>
<li>擁有無限的 off-chip memory bandwidth</li>
</ul>
<p>圖 1.3 就再現了它們論文中的一個圖表，顯示了他們在模型中發現的一個有趣的 trade-off：</p>
<ul>
<li>當一個大 cache 被少量 thread 共享時（如多核 CPU 的情況），效能將隨 thread 數量的增加而增加（MC Region）。</li>
<li>但是，一旦 thread 數量增加到 cache 無法容納整個工作集（working set，在 windows 中用到的 bytes）時，就會達到 Valley，效能下降。</li>
<li>然後，隨著 thread 的進一步增加，多執行緒技術也能隱藏較長的 off-chip latency，因此效能隨之提升（MT Region），即透過多執行緒來 tolerate 頻繁的 cache-miss。</li>
</ul>
<h3 id="GPU-的歷史要點："><a href="#GPU-的歷史要點：" class="headerlink" title="GPU 的歷史要點："></a>GPU 的歷史要點：</h3><ol>
<li><strong>Origins in the 1960s</strong>: Computer graphics technology dates back to the 1960s, marked by pioneering projects like Ivan Sutherland’s Sketchpad.起源於 1960 年代：電腦圖形技術可以追溯到 1960 年代，以伊凡·薩瑟蘭的 Sketchpad 等開創性項目為標誌。</li>
<li><strong>Early Role in Animation and Gaming</strong>: Graphics have played a crucial role in both off-line rendering for film animation and the development of real-time rendering for video games.早期在動畫和遊戲中的角色：圖形在電影動畫的離線渲染和視頻遊戲的實時渲染的發展中都扮演著至關重要的角色。</li>
<li><strong>Evolution of Video Cards</strong>: The progression started with text-only support in IBM’s MDA in 1981, followed by 2D and then 3D acceleration, which also benefited computer-aided design.顯示卡的演進：這個進程始於 1981 年 IBM 的 MDA 只支援文字，接著發展到 2D 和 3D 加速，同時也對電腦輔助設計有所裨益。</li>
<li><strong>Advancements in GPU Functionality</strong>: Early 3D graphics processors, like the NVIDIA GeForce 256, were mostly fixed-function. NVIDIA later introduced programmability with vertex and pixel shaders in 2001.GPU 功能的進步：早期的 3D 圖形處理器，如 NVIDIA GeForce 256，大多是固定功能的。NVIDIA 在 2001 年後引入了頂點和像素著色器的可編程功能。</li>
<li><strong>General-Purpose Computing on GPUs</strong>: Researchers found ways to use early GPUs for linear algebra, which led to more general-purpose computing applications on GPUs. NVIDIA’s GeForce 8 Series was the first commercial product to support this directly.研究人員發現了如何利用早期的 GPU 進行線性代數運算，這導致了更多通用計算應用在 GPU 上的出現。NVIDIA 的 GeForce 8 系列是第一個直接支援這一功能的商業產品。</li>
<li><strong>Innovations in GPU Architecture</strong>: The GeForce 8 Series added the ability to write to arbitrary memory addresses and introduced scratchpad memory. NVIDIA’s Fermi architecture later enabled caching of read-write data.GPU 架構的創新：GeForce 8 系列增加了對任意記憶體地址的寫入能力，並引入了暫存記憶體。NVIDIA 的 Fermi 架構後來實現了讀寫數據的緩存。</li>
<li><strong>Integration and Dynamic Parallelism</strong>: AMD’s Fusion architecture integrated the CPU and GPU on the same die. Dynamic parallelism was introduced, allowing for threads to be launched directly from the GPU.整合和動態平行處理：AMD 的 Fusion 架構將 CPU 和 GPU 整合在同一晶片上。引入了動態平行處理，允許直接從 GPU 啟動執行緒。</li>
<li><strong>Machine Learning Acceleration</strong>: The latest innovations, like NVIDIA’s Volta, include Tensor Cores designed specifically for machine learning acceleration.機器學習加速：最新的創新，如 NVIDIA 的 Volta，包括專為機器學習加速而設計的 Tensor Cores。</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><ul>
<li>Aamodt, T. M., Fung, W. W. L., &amp; Rogers, T. G. (2018). General-Purpose Graphics Processor Architectures. Morgan &amp; Claypool Publishers.</li>
<li>Hwu, W. W., Kirk, D. B., El Hajj, I. (2023). Programming Massively Parallel Processors: A Hands-on Approach. Morgan Kaufmann.</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Research/" class="category-chain-item">Research</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/GPU/">#GPU</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/12/%E7%94%A8%20.bat%20%E6%89%93%E9%80%A0%E5%AE%9A%E6%99%82%E7%B6%AD%E8%AD%B7%E7%9A%84%20Github%20Repo/" title="用 .bat 打造定時維護的 Github Repo">
                        <span class="hidden-mobile">用 .bat 打造定時維護的 Github Repo</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目錄</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜尋</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">關鍵字</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允許 JavaScript 運行的環境下瀏覽效果更佳</div>
  </noscript>
</body>
</html>
